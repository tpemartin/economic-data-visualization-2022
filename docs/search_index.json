[["index.html", "Economic Data Visualization 第 1 章 Prerequisites 1.1 Packages 1.2 Start a project 1.3 Setup environment 1.4 其他", " Economic Data Visualization Dr. Lin, Mau-Ting 2021 第 1 章 Prerequisites 1.1 Packages install.packages( c(&quot;showtext&quot;,&quot;extrafont&quot;, &quot;remotes&quot;) ) showtext and extrafont are for Chinese characters to show properly in the graph. remotes::install_github(&quot;tpemartin/econDV2&quot;, force=T) If your R/RStudio has trouble of installing packages, run the following: remotes::install_github(&quot;tpemartin/econR2&quot;) Then watch the following video to setup your R/RStudio properly. https://vimeo.com/682432399/a03ed1c806 1.2 Start a project You should always organize documents with the same purpose inside a unified folder, which is called a project folder, and initiate an R project with it. Start a new project for your ggplot environment: Project &gt; New Project… &gt; New Directory &gt; New Project Initiate a project and setup environment: Addins &gt; (under econDV2) Setup environment 1.3 Setup environment For each project, there are always some tools or packages you want to import each time. The easiest way to set them up is to create a .Rprofile file at the project folder (that is why we need to setup a project folder first). .Rprofile can contain any R scripts that you want to run each time your start your project. For this course, this will be the script you want to run each time: library(ggplot2) library(showtext) library(econDV2) # add google font: Noto Sans TC for chinese characters sysfonts::font_add_google(&#39;Noto Sans TC&#39;) # turn on showing chinese text in graph device showtext_auto() # set our graph theme to use the google font and a classic white back ground theme_set( theme( text=element_text(family = &quot;Noto Sans TC&quot;) )+ theme_classic() ) # some handy tool to use later through out the class ggenv=new.env() ggenv$gg &lt;- list( dash = econDV2::ggdash, geom = econDV2::ggbrowse, aes = econDV2::ggaes ) attach(ggenv) sysfonts::font_families() can show you what fonts you can use in R. Any font not there but in your operating system can be added to it via: sysfonts::font_add(&quot;QFangsong&quot;, regular=&quot;/Users/martinl/Library/Fonts/cwTeXQFangsong-Medium.ttf&quot;) cwTeX Chinese Font files can be downloaded from https://github.com/l10n-tw/cwtex-q-fonts-TTFs/releases 1.4 其他 後製軟體： Choose your own image editor, but make sure it support SVG editing. Here I use Boxy SVG. 程式排版： install.packages(&quot;styler&quot;) "],["geometries-and-aesthetics.html", "第 2 章 Geometries and Aesthetics 2.1 An Example 2.2 Environment 2.3 Inheritance 2.4 Graph export", " 第 2 章 Geometries and Aesthetics Available geometries Two steps: Step 1: What geometries do you see? Step 2: With a given geometry, what aesthetics do you observe? Geometries? Aesthetics? 2.1 An Example Geom: geom_point: x, y：varies with observations color (線框顏色): constant stroke (線框粗細): constant fill (內部塗色): constant size (點的大小): constant geom_text: x, y: varies with observations label: varies with observations hjust (文字水平錨點）：between 0 and 1 vjust (文字垂直錨點）: between 0 and 1 if(!require(&quot;R6&quot;)) install.packages(&quot;R6&quot;) Action = R6::R6Class(&quot;Action&quot;, public=list( change=function(data){ # print(self$data) data+3 } ), lock_objects = F) Person = R6::R6Class(&quot;Person&quot;, inherit = Action, public = list( data=NULL, newData=NULL, initialize = function(data){ print(data) self$data=data print(self) # invisible(self.data) }, changeMyself=function(){ print(super) self$newData = Action$public_methods$change(self$data) } )) p1 = Person$new(22) p1$data p1$changeMyself() p1$newData Action$public_methods$change &lt;- function(data) data**2 p1$data p1$changeMyself() p1$newData GG &lt;- R6::R6Class( &quot;GG&quot;, public=list( # fields data=NULL, initialize=function(data){ self$data = data; }, change=function(){ self$data+4 } ), lock_objects = F ) plot1= GG$new(data=1) class(GG) typeof(GG) print(GG) typeof(plot1) print(plot1) parent.env(plot1) 2.2 Environment person1 = list( name=&quot;Lisa&quot;, greet=function(){&quot;Hi, I am Lisa.&quot;}) person2 = list( name=&quot;Bob&quot;, greet=function(){&quot;Hi, I am Bob.&quot;} ) # created two objects in Global environment person1 person2 person1$greet() person2$greet() Environment is a special object created via: # create an environment myEnv = new.env() # populate the environment myEnv$person1 = list( name=&quot;Lisa2&quot;, greet=function(){paste(&quot;Hi, I am Lisa2.&quot;)}) myEnv$person2 = list( name=&quot;Bob2&quot;, greet=function(){&quot;Hi, I am Bob2.&quot;} ) # Get person1/2 from R search path starting from global environment person1$greet() person2$greet() # Get person1/2 from a specific environment myEnv$person1$greet() myEnv$person2$greet() You can also: myEnv = new.env() with(myEnv,{ person1 = list( name=&quot;Lisa2&quot;, greet=function(){paste(&quot;Hi, I am Lisa2.&quot;)}) person2 = list( name=&quot;Bob2&quot;, greet=function(){&quot;Hi, I am Bob2.&quot;} ) }) 2.2.1 Mutable changePerson1 = function(){ # search path: exec env -&gt; global env person1$name=&quot;John&quot; person1$greet=function() &quot;Hi I am John&quot; } # the object called is from the global env, but the object is not modified. changePerson1() person1$name person1$greet() Anything inside an environment can be changed no matter where the environment is called. changePerson1 = function(){ .GlobalEnv$person1$name=&quot;John&quot; .GlobalEnv$person1$greet=function() &quot;Hi I am John&quot; } changePerson1() person1 2.2.2 ggplot application Source data Data cleaning Basic plotting fine tune plot = new.env() plot$data = data.frame( x=c(52.5, 56, 58.5), y=c(48.6, 54.9, 58), label=c(&quot;Colombia&quot;, &quot;Norway&quot;, &quot;Germany&quot;) ) plot$graph = function(){ require(ggplot2) ggplot()+ geom_point(data=plot$data, # accessing to an object within an environment mapping=aes( x=x, y=y ), fill=&quot;blue&quot;, shape=21, color=&quot;black&quot;, stroke=1, size=1 ) } plot$graph() 2.2.3 Flexibility Environment object is flexible to change any member. plot$graph &lt;- function(){ require(ggplot2) ggplot()+ geom_point( data=plot$data, mapping=aes( x=x, y=y ), fill=&quot;blue&quot;, #input$fill_point shape=21, # default point is a circle without border, you need another type of point color=&quot;black&quot;, #input$color_point stroke=1, #input$stroke_point size=1 #input$size_point )+ geom_text( data=plot$data, mapping=aes( x=x, y=y, label=label ), hjust = 1, #input$hjust_text size = 1 #input$size_text ) } plot$graph() 2.2.4 Plot constructor Plot = function(.data=NULL, .graph=NULL){ self = new.env() self$data = .data self$graph = .graph return(self) } plot = Plot() plot$data = data.frame( x=c(52.5, 56, 58.5), y=c(48.6, 54.9, 58), label=c(&quot;Colombia&quot;, &quot;Norway&quot;, &quot;Germany&quot;) ) plot$graph = function(){ require(ggplot2) ggplot()+ geom_point(data=plot$data, # accessing to an object within an environment using self$ or plot$ mapping=aes( x=x, y=y ), fill=&quot;blue&quot;, shape=21, color=&quot;black&quot;, stroke=1, size=1 ) } plot$graph() # change data plot$data = data.frame( x=c(52.5, 46, 58.5), y=c(48.6, 54.9, 78), label=c(&quot;Colombia&quot;, &quot;Norway&quot;, &quot;Germany&quot;) ) plot$graph() # change graph plot$graph = function(){ require(ggplot2) ggplot()+ geom_point( data=plot$data, mapping=aes( x=x, y=y ), fill=&quot;blue&quot;, #input$fill_point shape=21, # default point is a circle without border, you need another type of point color=&quot;black&quot;, #input$color_point stroke=1, #input$stroke_point size=1 #input$size_point )+ geom_text( data=plot$data, mapping=aes( x=x, y=y, label=label ), hjust = 1, #input$hjust_text size = 1 #input$size_text ) } plot$graph() 2.2.5 econDV2::ggdash At every aesthetic element to be adjusted, attach #input${aesthetic_name} at the end of the line as: ggplot()+ geom_point( data=plot$data, mapping=aes( x=x, y=y ), fill=&quot;blue&quot;, #input$fill_point shape=21, # default point is a circle without border, you need another type of point color=&quot;black&quot;, #input$color_point stroke=1, #input$stroke_point size=1 #input$size_point )+ geom_text( data=Plot$data, mapping=aes( x=x, y=y, label=label ), hjust = 1, #input$hjust_text size = 1 #input$size_text ) Select only the ggplot() part of code. Run gg$dash() 2.2.6 ggdash more ggdash can control any input within a programming block myplot2 &lt;- { myshape = 21 #input$shape_point ggplot() + geom_point( data = data4plot$point$data, mapping = aes( x = x, y = y ), fill = &quot;#2fc1d3&quot;, shape = myshape, color = &quot;black&quot;, stroke = 1, size = 12 ) + geom_text( data = data4plot$text$data, mapping = aes( x = x + 0, #input$x_text y = y, label = label ), hjust = 0, size = 12 ) } myplot2 2.3 Inheritance 2.3.1 Data Common data source can be put in ggplot(): ALL geoms will use the same data to find aes() mapping, UNLESS the geom has its own data supplied. data = data4plot$text$data myplot &lt;- { ggplot(data = data, ) + geom_point( mapping = aes( x = x, y = y ), fill = &quot;#2fc1d3&quot;, shape = 21, color = &quot;black&quot;, stroke = 1, size = 12 ) + geom_text( # data = data4plot$text$data, mapping = aes( x = x, y = y, label = label ), hjust = 0, size = 12 ) } 2.3.2 Aesthetics myplot &lt;- { ggplot( data = data, mapping = aes(x=x, y=y) ) + geom_point( fill = &quot;#2fc1d3&quot;, shape = 21, color = &quot;black&quot;, stroke = 1, size = 12 ) + geom_text( mapping = aes( label = label ), hjust = 0, size = 12 ) } myplot plot_hightlightCountries &lt;- function(data) { myplot &lt;- { ggplot(data = data, ) + geom_point( mapping = aes( x = x, y = y ), fill = &quot;#2fc1d3&quot;, shape = 21, color = &quot;black&quot;, stroke = 1, size = 12 ) + geom_text( # data = data4plot$text$data, mapping = aes( x = x, y = y, label = label ), hjust = 0, size = 12 ) } myplot } 2.3.3 Stop data inheritance When a geom has its own data supplied, data inheritance stops. nonhighlightedCountries &lt;- data.frame( x=c(48, 52, 53), y=c(48, 53, 54) ) highlightedCountries &lt;- data4plot$text$data plot_allCountries &lt;- { plot_hightlightCountries(highlightedCountries) + geom_point( data = nonhighlightedCountries, aes( x=x, y=y ), size = 12, color= &quot;#a4dce6&quot; ) } plot_allCountries plot_allCountries &lt;- function(highlightedCountries, nonhighlightedCountries) { plot_hightlightCountries(highlightedCountries) + geom_point( data = nonhighlightedCountries, aes( x=x, y=y ), size = 12, color= &quot;#a4dce6&quot; ) } 2.3.4 Finish panel plot_obsessionWithBorders &lt;- { plot_allCountries( hightlightedCountries = highlightedCountries, unhighlightedCountries = unhighlightedCountries )+ geom_abline( aes( slope=1, intercept=0 ), color = &quot;#549ab6&quot;, linetype = 2, size=2 ) } plot_obsessionWithBorders plot_obsessionWithBorders + geom_abline( aes( slope=1, intercept=0 ), color = &quot;#549ab6&quot;, linetype = 2, size=2 ) hightlightXYequal &lt;- function(plot_obsessionWithBorders) { plot_obsessionWithBorders + geom_abline( aes( slope=1, intercept=0 ), color = &quot;#549ab6&quot;, linetype = 2, size=2 ) } 2.4 Graph export The easiest way to export the graph as you see on gg$dash() is to right click the image on the shiny dashboard and choose save image as to export the image. "],["layers.html", "第 3 章 Layers 3.1 Time series data 3.2 Aesthetics inheritance 3.3 Sequence of layers 3.4 Create your first geom 3.5 Summary 3.6 Exercise", " 第 3 章 Layers Geometries: geom_line Aesthetics: x, y, color; size source(&quot;support/time-trend.R&quot;) 3.1 Time series data package: lubridate Basic data types do not have time or date type. Time/Date are class that is constructed on top of character data, like &quot;2020-02-01&quot; &quot;2020-02-01 13:58:55&quot; All date/time data sources are normally input as character. It requires parsing for computer to under it is date/time. lubridate::ymd(&quot;2020-02-01&quot;) lubridate::ymd_hms(&quot;2020-02-01 13:58:55&quot;) # UTC time zone by default lubridate::ymd_hms(&quot;2020-02-01 13:58:55&quot;, tz=&quot;Asia/Taipei&quot;) date = lubridate::ymd(c(&quot;2020-02-01&quot;, &quot;2020-04-01&quot;, &quot;2020-06-01&quot;, &quot;2020-09-01&quot;)) data = list() data$Britain &lt;- data.frame( date = date, y = c(0, 50, 80, 100) ) data$Spain &lt;- data.frame( date = date, y = c(0, 32, 53, 103) ) data$Italy &lt;- data.frame( date = date, y = c(0, 50, 60, 99) ) ggplot(data=dataAll) + geom_line( aes( x=date, y=y ) ) ggplot(data=dataAll) + geom_line( aes( x=date, y=y, group=country ) ) 3.2 Aesthetics inheritance In the past, we have done data inheritance (i.e. data in ggplot()) and both data/aesthetics inheritance (i.e, data and mapping in ggplot()). Actually you can do only aesthetics inheritance as well. sizeInput = 2 #input$sizeInput plot &lt;- list() plot$p1 &lt;- { ggplot( mapping=aes( x=date, y=y ))+ geom_line( data=data$Britain, color=&quot;#096fa1&quot;, size = sizeInput )+ geom_line( data=data$Spain, color=&quot;#ad8c97&quot;, size = sizeInput )+ geom_line( data=data$Italy, color = &quot;#983d4d&quot;, size = sizeInput ) } plot$p1 3.3 Sequence of layers 3.3.1 Line stroke ggplot( mapping=aes( x=date, y=y ))+ geom_line( data=data$Britain, color=&quot;#096fa1&quot;, size = sizeInput ) + geom_line( # the last geom will be on the top data=data$Britain, color=&quot;black&quot;, size = sizeInput ) prop = 0.6 ggplot( mapping=aes( x=date, y=y ))+ geom_line( # the last geom will be on the top data=data$Britain, color=&quot;black&quot;, size = sizeInput ) + geom_line( data=data$Britain, color=&quot;#096fa1&quot;, size = sizeInput*prop ) 3.4 Create your first geom geom_lineWithStroke_error &lt;- function(data, sizeInput, prop) { geom_line( # the last geom will be on the top data=data, color=&quot;black&quot;, size = sizeInput ) + geom_line( data=data, color=&quot;#096fa1&quot;, size = sizeInput*prop ) } class(plot$p1) # ggplot class a list of 9 that complete the definitions of a plot gm &lt;- geom_line( # the last geom will be on the top data=data$Britain, color=&quot;black&quot;, size = sizeInput ) class(gm) # Layer class an environment that defines only a layer of a specific geometric structure and its aesthetics. part of a ggplot class object. + operator must have the preceding object a ggplot object. geom_lineWithStroke_error( data=data$Britain, sizeInput=2, prop=.6 ) The error comes from the function body. It uses + on two layer class objects. There is no ggplot object presented. ggplot()+... will always return a ggplot object. So all of below are ggplot objects: ggplot(), ggplot()+geom_point(...), ggplot()+geom_point(...)+geom_line(...) 3.4.1 Layer adding Instead of using + on each layers (i.e. adding geom one after the other), you can put all geom layers as a list, and use + to add the list all at once. Other than the conventional adding: ggplot( mapping=aes( x=date, y=y ))+ geom_line( data=data$Britain, color=&quot;black&quot;, size = sizeInput ) + geom_line( # the last geom will be on the top data=data$Britain, color=&quot;#096fa1&quot;, size = sizeInput*prop ) We can: ggplot( mapping=aes( x=date, y=y )) + list( geom_line( data=data$Britain, color=&quot;black&quot;, size = sizeInput ), geom_line( # the last geom will be on the top data=data$Britain, color=&quot;#096fa1&quot;, size = sizeInput*prop ) ) 3.4.2 New geom function A geom function that delivers a mixture of multiple geoms must return the mixture as a list, avoiding using + inside the function body. geom_lineWithStroke_prototype &lt;- function(data, sizeInput, prop) { list( geom_line( data=data, color=&quot;black&quot;, size = sizeInput ), geom_line( # the last geom will be on the top data=data, color=&quot;#096fa1&quot;, size = sizeInput*prop ) ) } { ggplot( mapping=aes( x=date, y=y ))+ geom_lineWithStroke_prototype( data=data$Britain, sizeInput, prop )+ geom_lineWithStroke_prototype( data=data$Spain, sizeInput, prop )+ geom_lineWithStroke_prototype( data=data$Italy, sizeInput, prop ) } 3.4.3 dot-dot-dot https://adv-r.hadley.nz/functions.html?q=dot-#fun-dot-dot-dot geom_lineWithStroke_prototype2 &lt;- function(data, sizeInput, prop, color, stroke, size) { list( geom_line( data=data, color=stroke, size = sizeInput ), geom_line( # the last geom will be on the top data=data, color=color, size = sizeInput*prop ) ) } { ggplot( mapping=aes( x=date, y=y ))+ geom_lineWithStroke_prototype2( data=data$Britain, sizeInput=sizeInput, prop=prop, color=&quot;#096fa1&quot;, stroke=&quot;white&quot; )+ geom_lineWithStroke_prototype2( data=data$Spain, sizeInput=sizeInput, prop=prop, color=&quot;#ad8c97&quot;, stroke=&quot;white&quot; )+ geom_lineWithStroke_prototype2( data=data$Italy, sizeInput=sizeInput, prop=prop, color=&quot;#983d4d&quot;, stroke=&quot;white&quot; ) } geom_lineWithStroke is an extension to an existing geom_line function. It would be better to make the input argument inline with geom_line so as to keep other geom_line options, such as linetype. help(geom_line) geom_lineWithStroke &lt;- function( mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, # set up default makes your function easy to use stroke = &quot;white&quot;, prop = 0.9, size = 2, ...){ list( geom_line( data=data, color=stroke, size = size ), geom_line( # the last geom will be on the top mapping = mapping, data = data, stat = stat, position = position, na.rm = na.rm, orientation = orientation, show.legend = show.legend, inherit.aes = inherit.aes, size = size*prop, ...) ) } ... is a special argument for function. It means “whatever input whose input name is not specified in function arguments. it can be passed directly into other functions who use .... it can be accessed via list(). mySum &lt;- function(...){ browser() argList &lt;- c(...) sum(argList) } mySum(2,3) greeting &lt;- function(name, ...){ browser() argList &lt;- list(...) extraGreeting &lt;- &quot;&quot; if(length(argList)!=0){ extraGreeting &lt;- paste(&quot; Your&quot;, names(argList), &quot; is &quot;, argList) } cat(&quot;Hi &quot;, name, &quot;. &quot;, extraGreeting) return(xx) } greeting(&quot;John&quot;, age=33) { ggplot( mapping=aes( x=date, y=y ))+ geom_lineWithStroke( data=data$Britain, color=&quot;#096fa1&quot; )+ geom_lineWithStroke( data=data$Spain, color=&quot;#ad8c97&quot; )+ geom_lineWithStroke( data=data$Italy, color=&quot;#983d4d&quot; ) } { ggplot( mapping=aes( x=date, y=y ))+ geom_lineWithStroke( data=data$Britain, color=&quot;#096fa1&quot;, linetype=2 )+ geom_lineWithStroke( data=data$Spain, color=&quot;#ad8c97&quot;, linetype=3 )+ geom_lineWithStroke( data=data$Italy, color=&quot;#983d4d&quot;, stroke=&quot;black&quot;, size=5 ) } 3.5 Summary Layers (of geoms) can be added on top of each other through + operator by either: ggplot object + geom1 + geom2; or ggplote object + list(geom1, geom2) When create a new geom function that consists of multiple geoms, use list(geom1, geom2) as function return. When writing a function input argument names: if in definition specifically WITHOUT default: it means something necessary. Users can not ignore. if in definition specifically WITH default: it means something necessary, but there is a good choice of default that users will be happy with it most of the time. ...: a flexible argument especially when our function body has a call to some other function that has ... 3.6 Exercise https://clauswilke.com/dataviz/visualizing-associations.html#associations-paired-data "],["categorical-data.html", "第 4 章 Categorical data 4.1 Aesthetics: group 4.2 Geom overlapping 4.3 Position: stack 4.4 Factor 4.5 Proportional data 4.6 Adding text 4.7 More on position 4.8 Coordination flip 4.9 Summary 4.10 Exercise", " 第 4 章 Categorical data 4.1 Aesthetics: group ggplot() + geom_line( mapping=aes( x=c(1, 2, 3), y=c(2, 3, 2), ) ) + geom_line( mapping=aes( x=c(1, 2, 3), y=c(5, 2, 6) ) ) Use group aesthetic to combine multiple same geom layers into one. ggplot() + geom_line( mapping=aes( x=c(1, 2, 3, 1, 2, 3), y=c(2, 3, 2, 5, 2, 6), group=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;), ) ) ggplot() + geom_line( mapping=aes( x=c(1, 2, 3, 1, 2, 3), y=c(2, 3, 2, 5, 2, 6), group=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;), color=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;) ) ) Any aesthetic differentiates group can replace group. ggplot() + geom_line( mapping=aes( x=c(1, 2, 3, 1, 2, 3), y=c(2, 3, 2, 5, 2, 6), # group=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;), color=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;) ) ) When there is no aesthetic mapping to differentiate groups, use group aesthetic mapping. 4.2 Geom overlapping When geom layers overlap, we can use alpha aesthetic. If multiple geometries are created within the one geom_ call (using grouping aesthetics), we can also set position: “stack”, “dodge” or “jitter” (some of them might not apply to certain geom_) https://clauswilke.com/dataviz/visualizing-proportions.html#fig:health-vs-age x is continuous, or discrete with many types y the cumulative proportion ggplot() + geom_area( mapping=aes( x=c(1, 2, 3), y=c(0.2, 0.3, 0.2), ) ) + geom_area( mapping=aes( x=c(1, 2, 3), y=c(0.4, 0.3, 0.52) + c(0.2, 0.3, 0.2) # the additive is for accumulative purpose ), alpha=0.5 ) 4.3 Position: stack put y on top of the overlapping geom’s y create accumulative result. ggplot() + geom_area( mapping=aes( x=c(1, 2, 3, 1, 2, 3), y=c(0.2, 0.3, 0.2, 0.4, 0.3, 0.52), fill=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;) ), position=&quot;stack&quot; #input$position ) stack position is accumulative; no need to compute the accumulative value yourself. the default position in geom_area is “stack”. Therefore, you can omit position argument. data_cat1 &lt;- data.frame( x=c(1, 2, 3, 1, 2, 3), y=c(0.2, 0.3, 0.2, 0.4, 0.4, 0.52), fill=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;) ) ggplot( data=data_cat1 ) + geom_area( mapping=aes( x=x, y=y, fill=fill ) ) When aesthetic mapping involves with unordered data, it will convert the data series into factor (unless the series is already a factor); conduct the mapping according to the level sequence of the converted factor. data_cat1$fill |&gt; factor() |&gt; levels() 4.4 Factor When grouping aesthetics vary the look of geometries across different groups of data, it is crucial that users declare the mapped series with proper class. factor(data_series, levels) parses data_series into a categorical data with expressing sequence defined by levels. If omit levels the level sequence will be determined by the collateral sequence defined by your operating system. ggplot( data=data_cat1 ) + geom_area( mapping=aes( x=x, y=y, fill=factor(fill, levels=c(&quot;m&quot;, &quot;f&quot;)) ) ) Here we declare factor on-the-go. We can also declare factor in the data frame first: data_cat1_copy &lt;- data_cat1 data_cat1_copy$fill |&gt; factor(levels=c(&quot;m&quot;, &quot;f&quot;)) -&gt; data_cat1_copy$fill |&gt; is a R 4.0+ equipped operator, which makes: f(x, ....) # equivalent to x |&gt; f(...) ggplot( data=data_cat1_copy ) + geom_area( mapping=aes( x=x, y=y, fill=fill ) ) 4.5 Proportional data data_cat2_wide &lt;- data.frame( x=c(1, 2, 3), y_a=c(0.2, 0.3, 0.2), y_b=c(0.4, 0.4, 0.52), y_c=c(0.4, 0.3, 0.28) ) data_cat2_wide |&gt; tidyr::pivot_longer( cols=y_a:y_c, names_to = &quot;fill&quot;, values_to= &quot;y&quot; ) -&gt; data_cat2 View(data_cat2) ggplot( data=data_cat2 ) + geom_area( mapping=aes( x=x, y=y, fill=fill ), color=&quot;white&quot; ) When x mapping series has limited cases and is discrete, a bar chart with position dodge is better. ggplot( data=data_cat2 ) + geom_col( mapping=aes( x=x, y=y, fill=fill ), color=&quot;white&quot;, width=0.8, #input$width size=0, #input$size position = &quot;dodge&quot; #input$position ) width: the width of the bar size: the size of the stroke Pie chart: not good for comparing proportion across more than one dimension library(dplyr) data_cat2 %&gt;% filter( x==1 ) -&gt; data_cat2_x1only ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + coord_polar( theta = &quot;y&quot; ) 4.6 Adding text adding text ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + geom_text( aes( x=x, y=y, label=fill ), position = &quot;stack&quot; ) geom_col stack sequence is based on fill level sequence. geom_text stack sequence is based on observation sequence. Grouping aesthetics determine the sequence of stacking. In geom_col, fill is the grouping aesthetic. To make geom_text stack labels in sequence as fill in geom_col, we can put group=fill in geom_text to create such a sequence. ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + geom_text( aes( x=x, y=y, label=fill, group=fill ), position = &quot;stack&quot; ) Change labels to represent the proportion values of y ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + geom_text( aes( x=x, y=y, label=y, # use y to label now group=fill ), position = &quot;stack&quot; ) position argument also takes position functions. When you know what type of position you want, you can use corresponding position function to fine tune the position. ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + geom_text( aes( x=x, y=y, label=y, group=fill ), position = position_stack(vjust=0.5) ) ggplot( data=data_cat2_x1only ) + geom_col( aes( x=x, y=y, fill=fill ) ) + geom_text( aes( x=x, y=y, label=y, group=fill ), position = position_stack(vjust=0.5) ) + coord_polar( theta = &quot;y&quot; ) + theme_void() When x-axis is also representing a categorical data: dy=0.03 # input$dy ggplot( data=data_cat2 ) + geom_col( mapping=aes( x=x, y=y, fill=fill ), color=&quot;white&quot;, width=0.8, #input$width position = &quot;dodge&quot; #input$position )+ geom_text( mapping=aes( x=x, y=y-dy, group=fill, label=y ), size=8, #input$size position=position_dodge(width= 0.8 #input$dodge ) ) text position_dodge has the same width as geom_col to ensure the same dodging distance. 4.7 More on position https://ggplot2.tidyverse.org/reference/index.html#section-position-adjustment 4.8 Coordination flip ggplot()+ geom_col( mapping= aes( x=c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), y=c(56, 77, 92) ) )+ coord_flip() Another common application of coord_flip is: dx=4 #input$dx h=0.5 #input$h dt=0 #input$dt ggplot()+ geom_col( mapping=aes( x=c(1, 1), y=c(306, 232), fill=c(&quot;biden&quot;,&quot;trump&quot;) ), width=1 )+ geom_segment( mapping=aes( x=1-h, y=270, xend=1+h, yend=270 ) )+ geom_text( mapping=aes( x=1+dt, y=270, label=&quot;270&quot; ), size=8 #input$text )+ xlim(1-dx, 1+dx)+ # make sure cover 0.5-1.5 so the bar width can be accomodate coord_flip()+ theme_void()+ theme(legend.position = &quot;none&quot;) 4.9 Summary Grouping aesthetic separate a data frame into various subsample data frame and apply the geom_ function to each one of them in the sequence determined by the mapping factor’s levels sequence. When group aesthetic and other aesthetic share the same mapping variable, group aesthetic can be ignored. When deal with grouping variable, values of y from different groups at the same x can have position choice: “identity”: respect ys as it is. “stack”: stack ys according to grouping level sequence. “dodge”: respect ys as it is but move their x values left and right according to grouping level sequence. 4.10 Exercise 1 2 3 4 "],["scale.html", "第 5 章 Scale 5.1 Legend 5.2 Time axis 5.3 XY axis 5.4 Color/Fill 5.5 Exercise", " 第 5 章 Scale In geom, aes(xxx=yyy), defines a mapping from data vector yyy to aesthetic vector xxx. To change or fine tune this mapping, you add scale_xxx_... to your ggplot object. In general, a mapping can be divided into two parts How to map? limits: the range of data vector to be mapped. values: the mapped values from limits. In the the mapping, what to show to the readers? This is about the information in legend (圖例說明) breaks: the picked values in limits. labels: the mapped values of breaks. name: the title of the legend. Depending on aesthetics, not all five settings will be necessary. 5.1 Legend data_cat1 &lt;- data.frame( x=c(1, 2, 3, 1, 2, 3), y=c(0.2, 0.3, 0.2, 0.4, 0.4, 0.52), fill=c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;) ) ggplot0 &lt;- list() 0 #input$null ggplot0$plot1 &lt;- ggplot( data=data_cat1 ) + geom_area( mapping=aes( x=x, y=y, fill=factor(fill, levels=c(&quot;m&quot;, &quot;f&quot;)) ) ) ggplot0$plot1 ggplot0$plot1 + scale_fill_discrete( name=&quot;Gender&quot;, breaks=c(&quot;m&quot;, &quot;f&quot;), labels=c(&quot;Male&quot;, &quot;Female&quot;) ) -&gt; ggplot0$plot2 ggplot0$plot2 On every graph, by default, there is legend and/or axis that show information of how aes=variable mapping is defined. However, those variable value expressions you see in the legend/axis are defined by labels (such as “Male”, “Female”), whose corresponding variable values are defined in breaks (such as “m” and “f”); and name gives lengend/axis a title (such as “Gender”). 5.2 Time axis Generate basic plot: dataSet1 &lt;- data.frame( x=1979:2018 ) set.seed(2038) dataSet1$y &lt;- sample(10:40, length(dataSet1$x), T) ggplot1 &lt;- list() ggplot()+ geom_step( data=dataSet1, mapping= aes( x=x, y=y ) ) -&gt; ggplot1$plot0 ggplot1$plot0 Define x-axis labels: breaks = c( 1979, seq(1985, 2015, by=5), 2018 ) labels = c( &quot;1979&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;2000&quot;, &quot;05&quot;, &quot;10&quot;, &quot;15&quot;, &quot;18&quot; ) ggplot1$plot0 + scale_x_continuous( breaks=breaks, labels=labels ) -&gt; ggplot1$plot1 ggplot1$plot1 Remove scale ticks ggplot1$plot1 + theme( axis.ticks.length.x = unit(0,&quot;mm&quot;) ) -&gt; ggplot1$plot1 ggplot1$plot1 Add ticks: major ticks: ticks that belong to constant time span labels minor ticks: ticks that are not major ticks. ticks &lt;- list() ticks$major &lt;- seq(1980, 2015, by=5) ticks$minor &lt;- c(1979, 2018) majorLength = 3 #input$length minor_majorRatio = 0.7 #input$ratio ggplot1$plot1 + geom_rug( mapping=aes( x=ticks$major ), outside=TRUE, # draw rug outside the plot panel size=0.5, #input$majorsize length=grid::unit( majorLength, &quot;mm&quot; ) ) + geom_rug( mapping=aes( x=ticks$minor ), outside = TRUE, size=0.5, #input$minorsize length=grid::unit( minor_majorRatio*majorLength, &quot;mm&quot; ) )+ coord_cartesian(clip=&quot;off&quot;) -&gt; # allow drawing outside the plot panel ggplot1$plot2 ggplot1$plot2 ggplot1$plot2 + theme( axis.text.x = element_text( margin = margin( 12 #input$margin ), size=16 #input$textSize )) margin(t=0, r=0, b=0, l=0, unit='pt') 5.2.1 Custom axis function Pull out all the axis-related building blocks: { # scale_x scale_x_continuous( breaks=breaks, labels=labels ) + theme( axis.ticks.length.x = unit(0,&quot;mm&quot;), axis.text.x = element_text( margin = margin( 12 #input$margin ), size=16 #input$textSize ) )+ geom_rug( mapping=aes( x=ticks$major ), outside=TRUE, # draw rug outside the plot panel size=0.5, #input$majorsize length=grid::unit( majorLength, &quot;mm&quot; ) ) + geom_rug( mapping=aes( x=ticks$minor ), outside = TRUE, size=0.5, #input$minorsize length=grid::unit( minor_majorRatio*majorLength, &quot;mm&quot; ) )+ coord_cartesian(clip=&quot;off&quot;) } Build a function: axis_x_continuouse_custom &lt;- function( breaks, labels, ticks_major, ticks_minor, ticks_major_length = 3, minor_major_tickLength_ratio = 0.7, text_size = 16, text_top_margin = 12, major_tick_size = 0.5, minor_tick_size = 0.5 ){ list( scale_x_continuous( breaks=breaks, labels=labels ), theme( axis.ticks.length.x = unit(0,&quot;mm&quot;), axis.text.x = element_text( margin = margin( text_top_margin #input$margin ), size=text_size #input$textSize ) ), geom_rug( mapping=aes( x=ticks_major ), outside=TRUE, # draw rug outside the plot panel size=major_tick_size, #input$majorsize length=grid::unit( ticks_major_length, &quot;mm&quot; ) ), geom_rug( mapping=aes( x=ticks_minor ), outside = TRUE, size=minor_tick_size, length=grid::unit( minor_major_tickLength_ratio*ticks_major_length, &quot;mm&quot; ) ), coord_cartesian(clip=&quot;off&quot;) ) } breaks = c( 1979, seq(1985, 2015, by=5), 2018 ) labels = c( &quot;1979&quot;, &quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;2000&quot;, &quot;05&quot;, &quot;10&quot;, &quot;15&quot;, &quot;18&quot; ) ticks_major &lt;- seq(1980, 2015, by=5) ticks_minor &lt;- c(1979, 2018) ggplot1$plot0 + axis_x_continuouse_custom( breaks=breaks, labels=labels, ticks_major = ticks_major, ticks_minor = ticks_minor ) 5.2.2 Advanced function Other input as default: when labels is omitted, use breaks value When ticks_minor is omitted, remove minor geom_rug. axis_x_continuouse_custom &lt;- function( breaks, labels = breaks, ticks_major, ticks_minor=NULL, ticks_major_length = 3, minor_major_tickLength_ratio = 0.7, text_size = 16, text_top_margin = 12, major_tick_size = 0.5, minor_tick_size = 0.5 ){ list( scale_x_continuous( breaks=breaks, labels=labels ), theme( axis.ticks.length.x = unit(0,&quot;mm&quot;), axis.text.x = element_text( margin = margin( text_top_margin #input$margin ), size=text_size #input$textSize ) ), geom_rug( data = data.frame( ticks_major=ticks_major ), mapping=aes( x=ticks_major ), outside=TRUE, # draw rug outside the plot panel size=major_tick_size, #input$majorsize length=grid::unit( ticks_major_length, &quot;mm&quot; ) ), if(!is.null(ticks_minor)){ geom_rug( data = data.frame( ticks_minor=ticks_minor ), mapping=aes( x=ticks_minor ), outside = TRUE, size=minor_tick_size, length=grid::unit( minor_major_tickLength_ratio*ticks_major_length, &quot;mm&quot; ) ) } else { NULL }, coord_cartesian(clip=&quot;off&quot;) ) } ggplot1$plot0 + axis_x_continuouse_custom( breaks=breaks, ticks_major = ticks_major ) There are many possible scale_x. We can build a axis_x_custom function that can take all possible scale_x_zzz as input, and return axis_x_zzz_custom function as an output. Function that can take function as input is called functional. Functionals that generate functions are called function generators. axis_x_custom &lt;- function(scale_x){ function( breaks, labels = breaks, ticks_major, ticks_minor=NULL, ticks_major_length = 3, minor_major_tickLength_ratio = 0.7, text_size = 16, text_top_margin = 12, major_tick_size = 0.5, minor_tick_size = 0.5 ){ list( scale_x( breaks=breaks, labels=labels ), theme( axis.ticks.length.x = unit(0,&quot;mm&quot;), axis.text.x = element_text( margin = margin( text_top_margin #input$margin ), size=text_size #input$textSize ) ), geom_rug( data = data.frame( ticks_major=ticks_major ), mapping=aes( x=ticks_major ), outside=TRUE, # draw rug outside the plot panel size=major_tick_size, #input$majorsize length=grid::unit( ticks_major_length, &quot;mm&quot; ) ), if(!is.null(ticks_minor)){ geom_rug( data = data.frame( ticks_minor=ticks_minor ), mapping=aes( x=ticks_minor ), outside = TRUE, size=minor_tick_size, length=grid::unit( minor_major_tickLength_ratio*ticks_major_length, &quot;mm&quot; ) ) } else { NULL }, coord_cartesian(clip=&quot;off&quot;) ) } } # generate axis_x_continuous_custom axis_x_continuous_custom2 &lt;- axis_x_custom(scale_x_continuous) ggplot1$plot0 + axis_x_continuous_custom2( breaks=breaks, ticks_major = ticks_major ) ggplot1$plot0 + axis_x_continuous_custom2( breaks=breaks, labels=labels, ticks_major = ticks_major, ticks_minor = ticks_minor ) 5.2.3 Time period When axis x is to represent a period: Basic plot: dataSet2 &lt;- data.frame( x=seq(from=lubridate::ymd(&quot;2013-01-01&quot;), to=lubridate::ymd(&quot;2013-12-31&quot;), by=&quot;1 day&quot;) ) dataSet2$y &lt;- { y &lt;- c(100) set.seed(2033) shocks &lt;- rnorm(length(dataSet2$x), sd=50) shocks for(t in 2:length(dataSet2$x)){ y[[t]] &lt;- 1*t + 0.6*y[[t-1]] + shocks[[t]] } y } 7-days moving average: install.packages(&quot;zoo&quot;) library(dplyr) dataSet2 %&gt;% mutate( y_smooth=zoo::rollmean(y, 7, na.pad=TRUE, align=&quot;center&quot;) ) -&gt; dataSet2 zoo::rollmean(y, window_width, padding_na_to_maintain_length, window_center) ggplot2 &lt;- list() ggplot2$plot1 &lt;- { ggplot()+ geom_line( data=dataSet2, mapping=aes( x=x, y=y_smooth ) ) } ggplot2$plot1 Add rug ticks and labels: axis_x_date_custom &lt;- axis_x_custom(scale_x_date) # breaks in middle of the month # set 15th of every month breaks=seq( from=lubridate::ymd(&quot;20130115&quot;), to=lubridate::ymd(&quot;20131215&quot;), by=&quot;1 month&quot; ) labels=lubridate::month( breaks, label=TRUE # Use month name based on OS locale ) labels ticks_major=c( seq( from=lubridate::ymd(&quot;20130101&quot;), to=lubridate::ymd(&quot;20131231&quot;), by=&quot;1 month&quot; ), lubridate::ymd(&quot;20131231&quot;)) Locales in your operating system determine how month and weekday should be expressed: * Windows: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c * Mac OS/linux: locales &lt;- system(&quot;locale -a&quot;, intern = TRUE) lubridate::month(breaks, locale = &quot;zh_TW&quot;, label = T # returned as month abbreviates ) lubridate::wday(breaks, locale = &quot;zh_TW&quot;, label = T # returned as month abbreviates ) ggplot2$plot1 + axis_x_date_custom( breaks=breaks, labels=labels, ticks_major=ticks_major, ticks_major_length = 2, #input$tickLength text_size = 14 #input$textSize ) 5.2.4 dot-dot-dot ... can pass any arguments not defined in function usage as one argument input that can be used in any place by calling ... . axis_x_custom &lt;- function(scale_x){ function( breaks, labels = breaks, ticks_major, ticks_minor=NULL, ticks_major_length = 3, minor_major_tickLength_ratio = 0.7, text_size = 16, text_top_margin = 12, major_tick_size = 0.5, minor_tick_size = 0.5, ... ){ list( scale_x( breaks=breaks, labels=labels, ... ), theme( axis.ticks.length.x = unit(0,&quot;mm&quot;), axis.text.x = element_text( margin = margin( text_top_margin #input$margin ), size=text_size #input$textSize ) ), geom_rug( data = data.frame( ticks_major=ticks_major ), mapping=aes( x=ticks_major ), outside=TRUE, # draw rug outside the plot panel size=major_tick_size, #input$majorsize length=grid::unit( ticks_major_length, &quot;mm&quot; ) ), if(!is.null(ticks_minor)){ geom_rug( data = data.frame( ticks_minor=ticks_minor ), mapping=aes( x=ticks_minor ), outside = TRUE, size=minor_tick_size, length=grid::unit( minor_major_tickLength_ratio*ticks_major_length, &quot;mm&quot; ) ) } else { NULL }, coord_cartesian(clip=&quot;off&quot;) ) } } axis_x_date_custom &lt;- axis_x_custom(scale_x_date) ggplot2$plot1 + axis_x_date_custom( breaks=breaks, labels=labels, ticks_major=ticks_major, ticks_major_length = 2, #input$tickLength text_size = 14, #input$textSize name=&quot;2013&quot; ) Multiple rug tick lengths: dataSet3 &lt;- data.frame( x=seq(from=lubridate::ymd(&quot;2011-01-01&quot;), to=lubridate::ymd(&quot;2014-06-01&quot;), by=&quot;1 month&quot;) ) dataSet3$y &lt;- { y &lt;- c(100) set.seed(2033) shocks &lt;- rnorm(length(dataSet3$x), sd=50) shocks for(t in 2:length(dataSet3$x)){ y[[t]] &lt;- 1*t + 0.6*y[[t-1]] + shocks[[t]] } y } dataSet3 %&gt;% mutate( y_smooth = zoo::rollmean(y, 5, na.pad=TRUE, align=&quot;center&quot;) ) -&gt; dataSet3 ggplot3 &lt;- list() ggplot()+ geom_line( data=dataSet3, mapping=aes( x=x, y=y_smooth ) ) -&gt; ggplot3$plot1 ggplot3$plot1 # breaks in middle of years, set at June, except 2014, set at March breaks = c( seq( from=lubridate::ymd(&quot;20110601&quot;), to=lubridate::ymd(&quot;20130601&quot;), by=&quot;1 year&quot; ), lubridate::ymd(&quot;20140301&quot;) ) labels = c(&quot;2011&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;) ticks_major=seq( from=lubridate::ymd(&quot;20110101&quot;), to=lubridate::ymd(&quot;20140101&quot;), by=&quot;1 year&quot; ) ticks_minor=seq( from=lubridate::ymd(&quot;20110101&quot;), to=lubridate::ymd(&quot;20140601&quot;), by=&quot;1 month&quot; ) ggplot3$plot1 + axis_x_date_custom( breaks=breaks, labels=labels, ticks_major = ticks_major, ticks_minor = ticks_minor ) Exercise 5.1 How do you put ticks inside? For date/time axis: * always assign ticks to the beginning and the end of the sample period. * when too many ticks are there, * try to label few of them, like labeling every 5 years, every 6 months, etc. Or * use period marking. * when use period marking, put labels in the middle of the period. 5.3 XY axis 5.3.1 Expansion and out-of-bound Among scale_x_... and scale_y_..., there are two arguments that might be handy: expand: define the padding around the limits of the plot. (圖形與xy軸的留白空間) oob (out of bound): define what to do when observations are out of limits bound. (超出作圖範圍的資料點要怎麼處置) dataSet &lt;- data.frame( x=rep(c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;),2), y=c(10, 20, 30, 10, 25, 33), group=c(rep(&quot;Art&quot;, 3), rep(&quot;General&quot;, 3)) ) ggplot()+ geom_col( data=dataSet, mapping= aes( x=x, y=y, fill=group ), position=&quot;dodge&quot;, width=0.8 )+ scale_y_continuous( expand = expansion(0, #input$multiply 0 #input$add ) ) expand = c(lowerBoundStretch, upperBoundStretch): lowerBoundStretch=c(a,b): lowerBound - a*range -b upperBoundStretch=c(c,d): upperBound + c*range +d expansion(m, n) will set a=c=m, b=d=n. 5.3.2 Secondary axis Rescale right series to left series range. Map LHS breaks to RHS 5.3.2.1 Preliminary analytics The relationship between two series. eu=readRDS(&quot;data/eu.Rds&quot;) ggplot4 &lt;- econDV2::Object(ggplot4) ggplot4$data = eu$data2 |&gt; dplyr::filter( time &gt;= &quot;2011-01-01&quot; ) ggplot4$summary$industrialProductionChange$range &lt;- { ggplot4$data$ind_procution_change |&gt; range(na.rm = T) } ggplot4$summary$unemploymentRate$range &lt;- { ggplot4$data$unemploymentRate |&gt; range(na.rm=T) } ggplot4$scatter_path &lt;- function(plotly=F, timeEnd=&quot;2014-06-01&quot;){ ggplot( data=ggplot4$data |&gt; subset( time &lt;= timeEnd), mapping=aes( x=ind_procution_change, y=unemploymentRate, label=time ) )+ geom_point()+geom_path() -&gt; gg if(plotly){plotly::ggplotly(gg)} else {gg} } ggplot4$scatter_path(T) Observe negative correlation between year-to-year change of industrial production and unemployment rate. 5.3.2.2 Graphic design A graph that shows negative correlated movements. ggplot4$ggplot &lt;- function(){ ggplot( data= ggplot4$data |&gt; subset(time &lt;= &quot;2014-06-01&quot;), mapping=aes(x=time) ) } ggplot4$industrialProduction &lt;- function(){ geom_col( mapping=aes( y=ind_procution_change ), fill=&quot;#04a2d0&quot; ) } ggplot4$unemployment &lt;- function(){ geom_line( aes( y=unemploymentRate ), color=&quot;#77230f&quot; ) } ggplot4$scale_y_ind_production &lt;- function(...){ scale_y_continuous( name=&quot;Industrial production&quot;, limits = c(-10, 11), breaks = seq(-10, 10, by=5), labels = seq(-10, 10, by=5), ... ) } ggplot4$scale_y_unemployment &lt;- function(...){ scale_y_continuous( name=&quot;Unemployment&quot;, limits = c(3, 13), breaks = seq(4,12, by=2), ... ) } ggplot4$just$industrialProduction &lt;- function(){ ggplot4$ggplot()+ ggplot4$industrialProduction()+ ggplot4$scale_y_ind_production() } ggplot4$just$unemployment &lt;- function(){ ggplot4$ggplot()+ ggplot4$unemployment()+ ggplot4$scale_y_unemployment() } ggplot4$twoSeries &lt;- function(...){ ggplot4$ggplot()+ ggplot4$industrialProduction()+ ggplot4$unemployment()+ ggplot4$scale_y_ind_production(...) } ggplot4$twoSeries() 5.3.2.3 Secondary axis ggplot4$sec_y_unemployment &lt;- function(){ # mapping left breaks to unemployment range # ggplot4$scale_y_ind_production() -&gt; left_y # left_y$breaks |&gt; range() transfer_leftBreaks = function(breaks){ scales::rescale(breaks, from=c(-10,10), to=c(4, 12)) } # left_y$breaks |&gt; transfer_leftBreaks() sec_axis( name=&quot;Unemployment&quot;, trans=transfer_leftBreaks, breaks=seq(4, 12, by=2) ) } ggplot4$twoSeries( sec.axis=ggplot4$sec_y_unemployment() ) 5.3.2.4 Rescale right series Unemployment is drawn based on left y scale, not based on the secondary (right) y scale. One plot can only have one y scale to define y coordinate (which will be the left y). Unemployment rate of 10 will be placed at the height of 10 as left y would show, but Right y 10 is actually in line with left -5; So We need to map unemployment rate of 10 to -5, which is an inverse transfer function of transfer_leftBreaks. ggplot4$scaled_unemployment &lt;- function(){ transferInv_leftBreaks &lt;- function(breaks){ scales::rescale(breaks, to=c(-10,10), from=c(4, 12)) } geom_line( aes( y=transferInv_leftBreaks(unemploymentRate) ), color=&quot;#77230f&quot; ) } ggplot4$twoSeries_recaled &lt;- function(){ ggplot4$ggplot() + ggplot4$industrialProduction() + ggplot4$scaled_unemployment() + ggplot4$scale_y_ind_production( sec.axis=ggplot4$sec_y_unemployment(), expand=expansion(0,add=c(0,1)) ) } ggplot4$twoSeries_recaled() 5.3.2.5 Time axis ggplot4$scale_x &lt;- function(){ scale_x_custom &lt;- econDV2::axis_x_custom(scale_x_date) scale_x_custom( breaks = lubridate::ymd(c(paste(2011:2013,&quot;06&quot;,&quot;01&quot;), &quot;2014-03-01&quot;)), labels = c(&quot;2011&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;), ticks_major = lubridate::ymd( paste(2011:2014, &quot;1&quot;, &quot;1&quot;) ), ticks_minor = seq( from=lubridate::ymd(&quot;2011-01-01&quot;), to=lubridate::ymd(&quot;2014-06-01&quot;), by=&quot;1 month&quot; ) ) } 5.3.2.6 gg$dash size=8 #input$size_title size_text=8 #input$size_text vjust=1 #input$vjust angle=0 #input$angel margin_l=-50 #input$margin_l margin_r=-50 #input$margin_r ggplot4$twoSeries_recaled() + ggplot4$scale_x() + theme( axis.title.x = element_blank(), axis.line.y=element_blank(), axis.ticks.y=element_blank(), panel.grid.major.y= element_line(color=&quot;#ececec&quot;), axis.text.y.left= element_text(color=&quot;#04a2d0&quot;, size=size_text ), axis.text.y.right= element_text(color=&quot;#77230f&quot;, size=size_text ), axis.title.y.left = element_text( color=&quot;#04a2d0&quot;, size=size, vjust=vjust, angle=angle, margin=margin( r=margin_l ) ), axis.title.y.right = element_text( color=&quot;#77230f&quot;, size=size, vjust=vjust, angle=angle, margin=margin( l=margin_r ) ), axis.ticks.length.y=unit(0,&quot;mm&quot;) ) 5.3.2.7 final plot ggplot4$finalPlot &lt;- function(){ size &lt;- 15 size_text &lt;- 19 vjust &lt;- 1 angle &lt;- 0 margin_l &lt;- -103 margin_r &lt;- -84 ggplot4$twoSeries_recaled() + ggplot4$scale_x() + theme( axis.title.x = element_blank(), axis.line.y = element_blank(), axis.ticks.y = element_blank(), panel.grid.major.y = element_line(color = &quot;#ececec&quot;), axis.text.y.left = element_text( color = &quot;#04a2d0&quot;, size = size_text ), axis.text.y.right = element_text( color = &quot;#77230f&quot;, size = size_text ), axis.title.y.left = element_text( color = &quot;#04a2d0&quot;, size = size, vjust = vjust, angle = angle, margin = margin( r = margin_l ) ), axis.title.y.right = element_text( color = &quot;#77230f&quot;, size = size, vjust = vjust, angle = angle, margin = margin( l = margin_r ) ), axis.ticks.length.y = unit(0, &quot;mm&quot;) ) } ggplot4$finalPlot() 5.4 Color/Fill 5.4.1 Discrete Set up simulated data: dataSet3 &lt;- data.frame( x=seq( from=lubridate::ymd(&quot;2020-01-03&quot;), to=lubridate::ymd(&quot;2020-08-12&quot;), by=&quot;1 day&quot; ) ) countries &lt;- c(&quot;Britain&quot;,&quot;France&quot;,&quot;Germany&quot;,&quot;Italy&quot;,&quot;Spain&quot;) slopes &lt;- c(0.1, 0.2, 0.3, 0.4, 0.5) for(i in seq_along(slopes)){ dataSet3[[countries[[i]]]] &lt;- 0 + slopes[[i]]*as.integer(dataSet3$x-dataSet3$x[[1]]) } dataSet3 |&gt; tidyr::pivot_longer( cols=&quot;Britain&quot;:&quot;Spain&quot;, names_to = &quot;country&quot;, values_to = &quot;y&quot; ) -&gt; dataSet3 Initiate a base plot: ggplot3 &lt;- list() ggplot3$data &lt;- dataSet3 ggplot3$plot1 &lt;- function(){ ggplot()+ geom_line( data=ggplot3$data, mapping=aes( x=x, y=y, group=country, color=country ) ) } ggplot3$plot1() Formulate the plotting process as a function has an advantage of data set substitutability. We can substitute ggplot3$data by: ggplot3$data &lt;- new_data ggplot3$plot1() This is because function is lazily evaluated which will look for ggplot3$data when it is called. The birth place of ggplot3$plot1 function is global environment. Therefore, any update of ggplot3$data in global environment before a call of ggplot3$plot1 will always be based on the updated value. Prepare color scale: ggplot3$color$limits &lt;- c(&quot;Britain&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;Spain&quot;) ggplot3$color$values &lt;- c(&quot;#984152&quot;, &quot;#1e80ab&quot;, &quot;#2ec1d2&quot;, &quot;#af959f&quot;, &quot;#e5b865&quot;) ggplot3$color$labels &lt;- c(&quot;英&quot;, &quot;法&quot;, &quot;德&quot;, &quot;義&quot;, &quot;西&quot;) Formulate the scale_color_manual call as a function ggplot3$scale_color_manual &lt;- function() { limits = ggplot3$color$limits values = ggplot3$color$values # a call to scale_color_manual scale_color_manual( limits = limits, values = values, breaks = limits, labels = ggplot3$color$labels ) } ggplot3$plot1() + ggplot3$scale_color_manual() {...} returns the visible value of the last executed line. ggplot3$axis_x_date_monthlyPeriod &lt;- function() { dd &lt;- data.frame( x = ggplot3$data$x ) require(dplyr) dd %&gt;% arrange(x) %&gt;% mutate( year=lubridate::year(x), month=lubridate::month(x) ) %&gt;% group_by(year,month) %&gt;% distinct() %&gt;% summarise( day1 = min(x), midlength = round(length(x)/2,0), breaks = day1 + lubridate::days(midlength), labels = lubridate::month(breaks, label=T) ) %&gt;% ungroup() -&gt; dx xrange &lt;- range(dd$x) rug_x &lt;- { c(xrange, dx$day1) |&gt; unique() |&gt; sort() } list( geom_rug( mapping=aes( x=rug_x ), outside = T ), coord_cartesian(clip=&quot;off&quot;), scale_x_date( breaks=dx$breaks, labels = dx$labels ), theme( axis.ticks.length.x = grid::unit(0,&quot;mm&quot;) ) ) } ggplot3$plot1() + ggplot3$scale_color_manual() + ggplot3$axis_x_date_monthlyPeriod() 5.4.2 Continuous 5.5 Exercise "],["map.html", "第 6 章 Map 6.1 Geographic geoms 6.2 Choropleth map 6.3 Map tile 6.4 Simple feature 6.5 Import Simple Feature Data 6.6 Taiwan drug problem", " 第 6 章 Map mp &lt;- econDV2::Map() 6.1 Geographic geoms 6.1.1 Point, Line and Polygon ggplot2 is equipped with geoms that can draw all kinds of geographic structure. fourPoints &lt;- data.frame( x=c(2, 3, 5, 3), y=c(-1, 0, 6, 6) ) geometry &lt;- list() geometry$ggplot &lt;- function(){ ggplot( data=fourPoints, mapping=aes( x=x, y=y ) ) } Points: geometry$points &lt;- geometry$ggplot() + geom_point() geometry$points Path: geometry$path &lt;- geometry$ggplot() + geom_path() geometry$path Polygon geometry$polygon &lt;- geometry$ggplot() + geom_polygon() geometry$polygon 6.1.2 Multipolygons A school consists of many buildings bigArea &lt;- data.frame( order=1:7, x=c(1, 5.5, 5.5, 1, 7, 8, 9), y=c(-2, -2, 7, 7, 8, 8 , 2), building=c(rep(&quot;building1&quot;, 4), rep(&quot;building2&quot;, 3)), # same school contour=c(rep(&quot;outer&quot;,4), rep(&quot;outer&quot;,3)) # two different buildings ) # draw each building separately ggplot()+geom_polygon( data=bigArea, mapping=aes(x=x, y=y, group=building) ) geom_polygon can draw a polygon with hole(s) by using group and subgroup aesthetics, with hole(s) as a polygon inside another. A building with a courtyard has two contours (one for the outer contour, the other for the courtyard contour). Both contours are polygons belong to the same group, but different subgroups. fourPoints$building=&quot;building1&quot; fourPoints$contour=&quot;courtyard&quot; fourPoints$order=8:11 bigArea |&gt; names() bigAreaWithHoles &lt;- dplyr::bind_rows( bigArea, fourPoints ) |&gt; arrange(building, order) View(bigAreaWithHoles) ggplot( data=bigAreaWithHoles ) + geom_polygon( aes( x=x, y=y, group=building, subgroup=contour ) ) 6.1.3 Fill polygons You can give different polygons different fills. ggplot( data=bigAreaWithHoles ) + geom_polygon( aes( x=x, y=y, group=building, subgroup=contour, fill=building ) ) 6.1.4 Application to world map We apply those geoms to draw some maps. world = ggplot2::map_data(&quot;world&quot;) group column is for group aesthetics for polygon. world0 &lt;- function(color=&quot;black&quot;, fill=&quot;white&quot;, size=0.35) { ggplot() + geom_polygon( data=world, aes( x=long, y=lat, group=group ), color=color, fill=fill, size=size ) } # Cartesian crs world0() # Cartesian with fixed aspect ratio world0() + coord_fixed() # Mercator projection: fixed asp, correct direction world0() + coord_map() # Mercator projection: fixed asp, correct direction, expand xlim world0() + coord_map(xlim = c(-180,180)) 6.2 Choropleth map A map with different fills to show certain social-economic data variation. 6.2.1 Backgroup fill and borders Though ggplot2 has geom function to work on Choropleth graph directly, I recommend to lay out a background map first. Map data world = ggplot2::map_data(&quot;world&quot;) Backgroup map base on Economist style: world0_background &lt;- function(){ world0( color=&quot;white&quot;, fill=&quot;#c8c5be&quot;, size=0.15) } world0_background() 6.2.2 Choropleth layer: value layer Another layer of geom_polygons but with different fills setup based on social-economic data. Instead of using geom_polygon as the background layer does, geom_map is an easier to use geom for Choropleth graph. geom_map is a wrapper of geom_polygon but with a much easier setup for Choropleth map purpose. use geom_map()+expand_limits() geom_map( data=`social-economic data`, mapping = aes( map_id = ..., fill = ... ), map =`map data` )+ expand_limits( x=`map data`$long, y=`map data`$lat ) map data from ggplot2::map_data (can be filtered if needed) social-economic data: a data frame with a column for map_id and a column for fill. map_id column must consist of the levels of map data’s region column. fill column: the social-economic data to show. expand_limits to ensure that no boundary points are right on the border of the plot. 6.2.2.1 WDI example Social-economic data se_data &lt;- jsonlite::fromJSON( &quot;https://www.dropbox.com/s/78jr6g6xtjz453b/women_in_parliament.json?dl=1&quot; ) # View(se_data) ggplot()+geom_map( data=se_data, mapping=aes( map_id=country, fill=women_in_parliament ), map=world )+ expand_limits(x=world$long, y=world$lat) # geom_map only plot those in the social-economic data ggplot()+geom_map( data=se_data[1:30,], mapping=aes( map_id=country, fill=women_in_parliament ), map=world )+ expand_limits(x=world$long, y=world$lat) World background ensure every country is on the map. world0_background() + geom_map( data=se_data[1:30, ], mapping=aes( map_id=country, fill=women_in_parliament ), map=world )+ expand_limits(x=world$long, y=world$lat) Fixed country name inconsistency between se_data and world data. se_data |&gt; mp$choropleth$rename_valueData_countryname( countryColumnName = &quot;country&quot;, pattern = c( &quot;Russia&quot;=&quot;Russian Federation&quot;, &quot;USA&quot;=&quot;United States&quot;, &quot;Iran&quot;=&quot;Iran, Islamic Rep.&quot;, &quot;Egypt&quot;=&quot;Egypt, Arab Rep.&quot;, &quot;Syria&quot;=&quot;Syrian Arab Republic&quot;, &quot;Yemen&quot;=&quot;Yemen, Rep.&quot;, &quot;UK&quot;=&quot;United Kingdom&quot;, &quot;Democratic Republic of the Congo&quot;=&quot;Congo, Dem. Rep.&quot;, &quot;Republic of Congo&quot;=&quot;Congo, Rep.&quot;, &quot;Ivory Coast&quot;=&quot;Cote d&#39;Ivoire&quot;, &quot;Venezuela&quot;=&quot;Venezuela, RB&quot; ) ) -&gt; se_data world0_background() + geom_map( data=se_data, mapping=aes( map_id=country, fill=women_in_parliament ), map=world )+ expand_limits(x=world$long, y=world$lat) choropleth0 &lt;- function(){ world0_background() + geom_map( data=se_data, mapping=aes( map_id=country, fill=women_in_parliament ), map=world )+ expand_limits(x=world$long, y=world$lat) } choropleth0() + theme_void() + labs( title=&quot;2020各國國會女性席次佔比(%)&quot; ) + theme( legend.position = &quot;bottom&quot; ) + guides( fill=guide_colorbar( title=NULL, barwidth = 4, #input$barwidth barheight = 0.35, #input$barheight ) ) # can also choropleth0() + scale_fill_gradient( guide = guide_colorbar(...) ) 6.2.3 Fill colors 6.2.3.1 scale_fill and palette function scale_fill_continuous(...) by default is based on: scale_fill_gradient(...) # which is based on the palette function palette_continuous generated by scales::seq_gradient_pal palette_continuous &lt;- scales::seq_gradient_pal( low = &quot;#132B43&quot;, high = &quot;#56B1F7&quot; ) two pigments “#132B43”, “#56B1F7” palette_continuous(seq(0, 1, by=0.2)) |&gt; scales::show_col() aes(fill=z) will rescale z according to # for sequential scales::rescale(z, from=range(z), to=c(0,1)) # for divergin scales::rescale(z, from=mid.point.value_stretching, to=c(-1,1)) scale_fill_discrete(...) by default is based on: scale_fill_hue(...) # which is based on the palette function palette_discrete generated by scales::hue_pal palette_discrete &lt;- scales::hue_pal(h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1) pigments: a hue (色像環) palette_discrete(3) |&gt; scales::show_col() palette_discrete(6) |&gt; scales::show_col() DiagrammeR::mermaid(&quot; graph LR A[continuous palette function]--&gt;B[continuous scales_fill] C[discrete palette function]--&gt;D[discrete scales_fill] &quot;) 6.2.3.2 colorspace Construct your palette function pal &lt;- colorspace::choose_palette(gui=&quot;shiny&quot;) Register colorspace::sequential_hcl(n = 7, h = 135, c = c(45, NA, NA), l = c(35, 95), power = 1.3, register = &quot;my_pal&quot;) colorspace::scale_fill_continuous_sequential(palette=&quot;my_pal&quot;) 6.2.3.3 application Color is to signal one direction strength. Gradient: Good for spot the highest and the lowest. Not easy to compare neighbors Adjust fill limits-values mapping: # reverse fill high-low value choropleth0() + scale_fill_gradient( high = &quot;#132B43&quot;, low = &quot;#56B1F7&quot;, na.value=&quot;#919191&quot; ) choropleth0() + colorspace::scale_fill_continuous_sequential(palette=&quot;my_pal&quot;, na.value=&quot;#919191&quot;) # use binned fill choropleth0() + scale_fill_binned( high = &quot;#003870&quot;, low = &quot;#d3e3f3&quot;, na.value=&quot;#919191&quot;, guide=guide_colorbar( reverse = FALSE, label.vjust = 0.5 ) ) choropleth0() + colorspace::scale_fill_binned_sequential( palette=&quot;my_pal&quot;, na.value=&quot;#919191&quot; ) 6.2.3.4 Cut your color Continuous color change is easy to spot those outliers, but not easy to compare non-outliers across borders. Discretize your continuous various and use scale_fill_manual to apply your sequential palette. Discretize continuous variable using cut: se_data2 &lt;- se_data # cut into 4 ordered levels se_data2$women_in_parliament |&gt; cut(c(0, 10, 20, 40, 50, 70), ordered_result = T) -&gt; .fct .fct |&gt; class() # rename levels for legend labels levels(.fct) &lt;- c(&quot;0-10%&quot;,&quot;10-20%&quot;,&quot;20-40%&quot;,&quot;40-50%&quot;, &quot;50-70%&quot;) .fct -&gt; se_data2$women_in_parliament choropleth1 &lt;- function(){ world0_background() + geom_map( data=se_data2, mapping=aes( map_id=country, fill=women_in_parliament ), map=world ) } choropleth1() + scale_fill_brewer(type=&quot;seq&quot;, na.value=&quot;#919191&quot;) choropleth1() + colorspace::scale_fill_discrete_sequential( palette=&quot;my_pal&quot;, na.value=&quot;#919191&quot; ) 6.2.3.5 Diverging color se_data3 &lt;- se_data se_data3$women_in_parliament |&gt; scales::rescale( from=c(0, 100), to=c(-1, 1) ) -&gt; se_data3$women_in_parliament choropleth3 &lt;- function(){ world0_background() + geom_map( data=se_data3, mapping=aes( map_id=country, fill=women_in_parliament ), map=world ) } colorspace package: ## Register custom color palette colorspace::diverging_hcl(n = 7, h = c(255, 12), c = c(50, 80), l = c(20, 97), power = c(1, 1.3), register = &quot;man_woman&quot;) choropleth3() + colorspace::scale_fill_binned_diverging( labels = function(x) (x+1)*50, palette=&quot;man_woman&quot; ) choropleth0() + colorspace::scale_fill_binned_diverging( mid=50, palette=&quot;man_woman&quot; ) 6.3 Map tile 6.3.1 ggmap Two steps: get_xxxmap to obtain raster map image. ggmap to produce a gg(plot) object as a background layer. 6.3.2 get_googlemap taipei_google &lt;- ggmap::get_googlemap( center = c(long=121.4336018, lat=25.0341671), zoom = 10, scale=2 ) taipei0 &lt;- function(){ ggmap(taipei_google) } 6.3.3 get_stamenmap taipei_stamen &lt;- ggmap::get_stamenmap( bbox = c(left = 121.0316, bottom = 24.7384, right = 122.1096, top = 25.3114), zoom=9, maptype = &quot;toner-lite&quot; ) taipei1 &lt;- function(){ ggmap(taipei_stamen) } You can copy map info from Google map link https://www.google.com/maps/@24.9475275,121.3795888,15z then: # mp &lt;- econDV2::Map() mp$extract$googleMapLocation() # then paste to get_googlemap Copy map info from OSM map bbox then: mp$extract$osmBBox() # then paste to get_stamenmap 6.4 Simple feature install.packages(&quot;sf&quot;) https://r-spatial.github.io/sf/ Another type of geographic data structure. a new class. Each value in a simple feature vector represents a form of geometry (called feature) and its geographic notation (i.e. latitude and longitude); and could carry its coordinate reference system. Each value is a parsing result from sf::st_xxx functions where xxx can be point (台北大學的一個地標，如YouBike站), multipoint (台北大學所有地標), linestring(台北大學的一條路徑), polygon(台北大學的一棟建築), multilinestring(台北大學的所有路徑), multipolygon(台北大學的所有建築), or geometrycollection(整個台北大學) 6.4.1 Define simple features A simple feature is composed of numeric vector, matrix, or list. No data frame is used. geoValues &lt;- list() geoValues$simple_feature$point &lt;- sf::st_point( c(24.9433123, 121.3699526) ) geoValues$simple_feature$multipoint &lt;- sf::st_multipoint( rbind( # will form a matrix c(24.9443019, 121.3714944), # 1st point c(24.9440709, 121.3728518) # 2nd point ) ) geoValues$simple_feature$linestring &lt;- sf::st_linestring( rbind( c(24.9423755, 121.3679438), # 1st trace point c(24.9429941, 121.3679432), # 2nd trace point c(24.9432087, 121.3686713) # 3rd trace point ) ) geoValues$simple_feature$polygon &lt;- sf::st_polygon( list( # 1st closed trace rbind( c(24.9441895, 121.3695181), c(24.9442244, 121.3692544), c(24.9437158, 121.3694094), c(24.9438647, 121.3696271), c(24.9441895, 121.3695181) # close the polygon ) ) ) # polygon: a list consists of matrices. class(geoValues$simple_feature$point) class(geoValues$simple_feature$linestring) class(geoValues$simple_feature$polygon) # all have sfg class Simple feature value can be graphed directly via geom_sf() geoValues$simple_feature$polygon |&gt; ggplot()+geom_sf() 6.4.2 Form simple feature column A collection column of multiple simple features. sf::st_sfc(geoValues$simple_feature) -&gt; geoValues$simple_feature_column class(geoValues$simple_feature_column) # &quot;sfc_GEOMETRY&quot; &quot;sfc&quot; # has class sfc geoValues$simple_feature_column |&gt; ggplot()+geom_sf() 6.4.3 Form simple feature data frame A simple feature data frame is basically a data frame with a column named geometry which is a list of each obervation’s simple feature value. # initiate a data frame df_sf &lt;- data.frame( name=c(&quot;landmark 1&quot;, &quot;must-see landmarks&quot;, &quot;path 1&quot;, &quot;building 1&quot;) ) # add simple feature column df_sf |&gt; sf::st_set_geometry(geoValues$simple_feature_column) -&gt; geoValues$simple_feature_df class(df_sf) # only &quot;data frame&quot; df_sf |&gt; dplyr::mutate( geometry=geoValues$simple_feature_column ) -&gt; df_sf2 class(df_sf2) # still a &quot;data frame&quot; # Must go through sf::st_set_geometry to get sf class class(geoValues$simple_feature_df) # &quot;sf&quot; &quot;data.frame&quot; geoValues$simple_feature_df |&gt; ggplot()+geom_sf() 6.5 Import Simple Feature Data 6.5.1 From SHP file https://tpemartin.github.io/economic-data-visualization/zh-tw/annotation-and-maps.html#%E8%AE%80%E5%85%A5shp%E6%AA%94 台灣的sf data太細，以平常輸出並不需要這麼細，可以進行簡化。使用： sf_data |&gt; mp$sf$simplify() -&gt; sf_simplified_data 6.5.2 From OSM Define bounding box Find feature key and value Make open pass query to get sf data. bbox = c(left = 121.0316, bottom = 24.7384, right = 122.1096, top = 25.3114) |&gt; osmdata::opq() |&gt; osmdata::add_osm_feature(key=&quot;admin_level&quot;, value=&quot;4&quot;) |&gt; osmdata::osmdata_sf() -&gt; taipei_osm If you have multiple features to request, chain add_osm_features one after the other. OR bbox = c(left = 121.0316, bottom = 24.7384, right = 122.1096, top = 25.3114) features = c(&quot;admin_level&quot;=&quot;4&quot;) mp$osm$request_data( bbox, features = features ) -&gt; taipei_osm features is a named character vector, with keys be element names and values be element values. taipei_osm$osm_multipolygons |&gt; dplyr::filter(name != &quot;臺灣省&quot;) -&gt; sf_northTaipei sf_northTaipei |&gt; ggplot()+geom_sf() sf_northTaipei |&gt; ggplot()+geom_sf(aes(fill=name)) 6.5.3 sf overlay ggmap Taipei MRT bbox = c(left = 121.0316, bottom = 24.7384, right = 122.1096, top = 25.3114) features = c(&quot;railway&quot;= &quot;subway&quot;) mp$osm$request_data( bbox, features ) -&gt; taipei_mrt taipei_mrt$osm_lines |&gt; ggplot()+geom_sf() # Error, since ggmap has some aes setting at the ggplot() stage which will be inherited by all the following geoms taipei1()+ geom_sf( data=taipei_mrt$osm_lines, color=&quot;dodgerblue&quot; ) taipei1()+ geom_sf( data=taipei_mrt$osm_lines, color=&quot;dodgerblue&quot;, inherit.aes = FALSE ) sf overlay google map from ggmap might have problem. If it does, try the following tip: https://github.com/dkahle/ggmap/issues/160#issuecomment-966812818 6.5.4 data frame overlay ggmap taipei_mrt$osm_lines |&gt; sf::st_coordinates() -&gt; coordinates coordinates |&gt; class() taipei1() + geom_path( data=coordinates |&gt; as.data.frame(), mapping=aes( x=X, y=Y, group=L1 ), inherit.aes = FALSE ) 6.6 Taiwan drug problem sf_taiwan_simplified &lt;- econDV2::sf_taiwan_simplified sf_taiwan_simplified$台灣本島$縣市 |&gt; ggplot()+geom_sf() sf_taiwan_simplified$台灣本島$鄉鎮區 |&gt; ggplot()+geom_sf() Cast the geometry column to have uniform feature if your want to use plotly::ggplotly later: # Originally polygons mixed with multipolygons sf_taiwan_simplified$台灣本島$鄉鎮區 |&gt; sf::st_geometry() # re-cast to uniform multipolygon sf_taiwan_simplified$台灣本島$鄉鎮區 |&gt; sf::st_cast(&quot;MULTIPOLYGON&quot;) -&gt; sf_taiwan_simplified$台灣本島$鄉鎮區 mp &lt;- econDV2::Map() mp$sf$make_background_map 底圖製作 6.6.1 縣市底圖 econDV2::Object(background) sf_taiwan_simplified$台灣本島$縣市 |&gt; mp$sf$make_background_map() background$台灣本島$縣市 &lt;- function(){ sf_taiwan_simplified$台灣本島$縣市 |&gt; mp$sf$make_background_map( color=&quot;white&quot;, size=0.14 ) } background$台灣本島$縣市() If you don’t know how much to crop and want to explore different possibilities, you can: sf_taiwan_simplified$縣市 |&gt; mp$sf$gg_crop() 6.6.2 各鄉/鎮/區底圖 background$台灣本島$鄉鎮區 &lt;- function(){ sf_taiwan_simplified$台灣本島$鄉鎮區 |&gt; sf::st_cast(&quot;MULTIPOLYGON&quot;) |&gt; mp$sf$make_background_map( color=&quot;white&quot;, size=0.14 ) } background$台灣本島$鄉鎮() 6.6.3 stamenmap底圖 bbox &lt;- c(left=119.99690, bottom=21.89988, right=122.00000, top=25.29999) econDV2::Object(taiwan_stamen) # toner-lite taiwan_stamen$tonerlite &lt;- ggmap::get_stamenmap(bbox, maptype=&quot;toner-lite&quot;, zoom=9) background$台灣本島$tonerlite &lt;- function(){ ggmap::ggmap(taiwan_stamen$tonerlite) } background$`台灣本島`$tonerlite() # terrain taiwan_stamen$terrain &lt;- ggmap::get_stamenmap(bbox, maptype=&quot;terrain&quot;, zoom=9) background$台灣本島$terrain &lt;- function(){ ggmap::ggmap(taiwan_stamen$terrain, darken=c(&quot;0.3&quot;, &quot;white&quot;)) } background$台灣本島$terrain() 6.6.4 毒品破獲 創立帶有geometry column的sf毒品資料 繪製面量圖 econDV2::Object(drug) drug$data &lt;- jsonlite::fromJSON(&quot;https://www.dropbox.com/s/dry3nvahkmcmqoi/drug.json?dl=1&quot;) drug$data &lt;- drug$data |&gt; dplyr::filter(發生西元年==&quot;2018&quot;) # 計算不同發生地點的案件破獲次數 library(dplyr) drug$data |&gt; group_by(發生地點) |&gt; summarise( 案件次數=n(), 案件次數2=cut(案件次數, c(0, 10, 20, 30)) ) -&gt; drug$data_frequency 6.6.4.1 create sf econ-social data left_data &lt;- sf_taiwan_simplified$`台灣本島`$鄉鎮區 library(sf) # You need this for dplyr join functions to work with sf class data frame right_data &lt;- drug$data_frequency |&gt; mutate( 發生地點= stringr::str_replace(發生地點, &#39;台&#39;, &quot;臺&quot;)) ## left_join drug$join$left &lt;- { left_data |&gt; dplyr::left_join( right_data, by=c(&quot;map_id&quot;=&quot;發生地點&quot;) ) } ## right_join drug$join$right &lt;- { left_data |&gt; dplyr::right_join( right_data, by=c(&quot;map_id&quot;=&quot;發生地點&quot;) ) }## inner_join drug$join$inner &lt;- { left_data |&gt; dplyr::inner_join( right_data, by=c(&quot;map_id&quot;=&quot;發生地點&quot;) ) } drug$join$left |&gt; ggplot()+geom_sf() # right covers some small island data whose geometry is empty drug$join$right |&gt; ggplot() + geom_sf() # inner like right but no small island data drug$join$inner |&gt; ggplot() + geom_sf() drug$sf &lt;- drug$join$inner 6.6.4.2 overlay sf background drug$map$choropleth0 &lt;- function(){ background$`台灣本島`$鄉鎮區() + geom_sf( data=drug$sf, mapping=aes( fill=案件次數 ), color=&quot;white&quot;, size=0.15 ) } drug$map$choropleth0() # mp$choose_palette() drug$register_palette &lt;- function(){ colorspace::sequential_hcl(n = 3, h = c(-83, 20), c = c(65, NA, 18), l = c(32, 90), power = c(0.5, 1), rev = TRUE, register = &quot;drug&quot;) } drug$register_palette() drug$map$choropleth0() + colorspace::scale_fill_continuous_sequential( palette=&quot;drug&quot;, na.value=&quot;#dbd7a8&quot; ) drug$map$choropleth1 &lt;- function(){ background$`台灣本島`$鄉鎮區() + geom_sf( data=drug$sf, mapping=aes( fill=案件次數2, label=map_id ), color=&quot;white&quot;, size=0.15 ) } drug$map$choropleth1() + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=&quot;#dbd7a8&quot; ) + theme_void() -&gt; drug$map$choropleth_final drug$map$choropleth_final plotly::ggplotly( drug$map$choropleth_final ) If you want to make the entire Taiwan island’s choropleth map down to “縣市” or “鄉鎮區”, you can also use: econDV2::geom_sf_taiwan which only need social-econ data with map_id. It will create sf social-econ data in the background for you. econDV2::geom_sf_taiwan default at cast2multipolygon=T to ensure plotly::ggplotly work. ggplot()+ econDV2::geom_sf_taiwan( data=drug$data_frequency, mapping=aes( fill=案件次數 ), map_id = &quot;發生地點&quot;, type=&quot;鄉鎮區&quot; ) last_plot() + colorspace::scale_fill_continuous_sequential( palette=&quot;drug&quot;, na.value=&quot;#dbd7a8&quot; ) plotly::ggplotly(last_plot()) background map design change is also possible. ggplot()+ econDV2::geom_sf_taiwan( data=drug$data_frequency, mapping=aes( fill=案件次數2 ), color=&quot;white&quot;, size=0.15, map_id = &quot;發生地點&quot;, type=&quot;鄉鎮區&quot;, background.fill = &quot;#ebffd9&quot;, background.color = &quot;#d9d9d9&quot;, background.size = 0.1 ) last_plot() + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=&quot;#dbd7a8&quot; ) + theme_void() plotly::ggplotly(last_plot()) 6.6.4.3 overlay stamenmap background drug$map$overstamen_tonerlite &lt;- background$`台灣本島`$tonerlite() + geom_sf( data=drug$sf, mapping=aes( fill=案件次數2, label=map_id ), color=&quot;white&quot;, size=0.15, alpha=0.3, inherit.aes = F ) + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=ggplot2::alpha(&quot;#dbd7a8&quot;, 0.1) ) drug$map$overstamen_tonerlite plotly::ggplotly(drug$map$overstamen_tonerlite) The overlay is slightly off due to some bug in ggmap. To fix it, you can use econDV2::ggmap2() + econDV2::geom_sf_overggmap() drug$map$overstamen_tonerlite_fixed &lt;- econDV2::ggmap2(taiwan_stamen$tonerlite)+ econDV2::geom_sf_overggmap( data=drug$sf, mapping=aes( fill=案件次數2, label=map_id ), color=&quot;white&quot;, size=0.15, alpha=0.7, inherit.aes = F ) + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=ggplot2::alpha(&quot;#dbd7a8&quot;, 0.1) )+theme_void() drug$map$overstamen_tonerlite_fixed plotly::ggplotly(drug$map$overstamen_tonerlite_fixed) There is still some unfit due to the fact that sf geometry is simplified. Terrain drug$map$overstamen_terrain &lt;- background$`台灣本島`$terrain() + geom_sf( data=drug$sf, mapping=aes( fill=案件次數2, label=map_id ), color=&quot;white&quot;, size=0.15, alpha=0.7, inherit.aes = F ) + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=ggplot2::alpha(&quot;#dbd7a8&quot;, 0.1) ) drug$map$overstamen_terrain drug$map$overstamen_terrain_fixed &lt;- econDV2::ggmap2(taiwan_stamen$terrain) + econDV2::geom_sf_overggmap( data=drug$sf, mapping=aes( fill=案件次數2, label=map_id ), color=&quot;white&quot;, size=0.15, alpha=0.5, inherit.aes = F ) + colorspace::scale_fill_discrete_sequential( palette=&quot;drug&quot;, na.value=ggplot2::alpha(&quot;#dbd7a8&quot;, 0.1) )+theme_void() drug$map$overstamen_terrain_fixed plotly::ggplotly(drug$map$overstamen_terrain_fixed) "],["color.html", "第 7 章 Color 7.1 Group aesthetics", " 第 7 章 Color date = lubridate::ymd(c(&quot;2020-02-01&quot;, &quot;2020-04-01&quot;, &quot;2020-06-01&quot;, &quot;2020-09-01&quot;)) data = list() data$Britain &lt;- data.frame( date = date, y = c(0, 50, 80, 100) ) data$Spain &lt;- data.frame( date = date, y = c(0, 32, 53, 103) ) data$Italy &lt;- data.frame( date = date, y = c(0, 50, 60, 99) ) dataAll &lt;- purrr::map_dfr( names(data), ~{ cbind(data[[.x]], data.frame(country=.x)) } ) dataAll is a grouped data 7.1 Group aesthetics When you have a grouped data frame and intend to draw by groups, you need to set the aesthetics group equal to the group variable in your data frame. Without group aes: ggplot(data = dataAll) + geom_line( aes( x = date, y = y ) ) With group aes: ggplot(data = dataAll) + geom_line( aes( x = date, y = y, group = country ) ) Using aesthetics other than x, y can function as group aesthetic as well: ggplot(data = dataAll) + geom_line( aes( x = date, y = y, linetype = country ) ) ggplot(data = dataAll) + geom_line( aes( x = date, y = y, color = country ) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
